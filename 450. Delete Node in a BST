/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* ans;
    
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* parent = NULL;
        ans = root;
        recur(root, key, parent); 
        return ans;
    }
    
    void recur ( TreeNode* root, int key, TreeNode* parent){
        if(root==NULL) return;
        
        if (root->val == key){
            
            if(parent == NULL){
                
                if(root->right != NULL && root->right !=NULL){
                    
                    auto tmp = root->right;
                    while(tmp->left!=NULL) tmp = tmp->left;
                    tmp->left = root->left; 
                    ans = root->right;
                }
                
                else if(root->right == NULL) ans = root->left;
                
                else ans = root->right;
            }
            
            else if(parent->left == root){
                
                if(root->right == NULL) parent->left = root->left;
                
                else{
                    parent->left = root->right;
                    auto tmp = root->right;
                    while(tmp->left!=NULL) tmp = tmp->left;
                    tmp->left = root->left; 
                }
            }
            
            else{
                
                if(root->right == NULL) parent->right = root->left;
                
                else{
                    parent->right = root->right;
                    auto tmp = root->right;
                    while(tmp->left!=NULL) tmp = tmp->left;
                    tmp->left = root->left; 
                }
                
            }
            
            delete root;
            return;
        }
        
        recur(root->left, key, root);
        recur(root->right, key, root);
    }
    
		// TreeNode* deleteNode(TreeNode* root, int key) {
		// if(!root) return nullptr;
		// // search for key node
		// if(root -> val < key) root -> right = deleteNode(root -> right, key);
		// else if(root -> val > key) root -> left = deleteNode(root -> left, key);
		// else { // root -> val == key
		// auto toDelete = root;
		// if(!root -> left || !root -> right) 
		// root = root -> left ? root -> left : root -> right;
		// else {
		// 		auto cur = root, par = root;
		// root = root -> right;
		// while(root -> left) par = root, root = root -> left;  // finding smallest in right subtree
		// cur -> val = root -> val;                             // replace node to be deleted- cur with value of smallest node found
		// 		// take care of child node...same as above
		// if(par -> left == root) par -> left = root -> right;
		// else par -> right = root -> right;
		// 		toDelete = root;
		// root = cur;
		// }
		// delete toDelete;            			
		// }
		// return root;
		// }
};